¬°Perfecto, David! Aqu√≠ tienes un ejemplo completo de una soluci√≥n en .NET 6+ que implementa un job de Quartz para purgar registros de tres tablas distintas a una base de datos hist√≥rica, con configuraci√≥n parametrizable desde `appsettings.json`, usando Entity Framework Core e interfaces limpias para mantener una arquitectura mantenible y escalable.

---

## üìÅ `appsettings.json`
```json
{
  "ConnectionStrings": {
    "DefaultConnection": "Server=.;Database=PrincipalDb;Trusted_Connection=True;",
    "HistoricalDb": "Server=.;Database=HistoricoDb;Trusted_Connection=True;"
  },
  "DataPurgeJob": {
    "PurgeThresholdInMonths": 3,
    "Tables": [
      { "Name": "Eventos", "KeyColumn": "FechaEvento" },
      { "Name": "LogTransacciones", "KeyColumn": "Fecha" },
      { "Name": "SesionesUsuario", "KeyColumn": "FechaCierre" }
    ]
  }
}
```

---

## üß© `TableInfo.cs`
```csharp
public class TableInfo
{
    public string Name { get; set; }
    public string KeyColumn { get; set; }
}
```

---

## üîå Interface: `IDataPurger.cs`
```csharp
public interface IDataPurger
{
    Task PurgeOldRecordsAsync(int months, CancellationToken cancellationToken);
}
```

---

## ‚öôÔ∏è Implementaci√≥n: `DataPurger.cs`
```csharp
public class DataPurger : IDataPurger
{
    private readonly IConfiguration _config;
    private readonly IServiceScopeFactory _scopeFactory;

    public DataPurger(IConfiguration config, IServiceScopeFactory scopeFactory)
    {
        _config = config;
        _scopeFactory = scopeFactory;
    }

    public async Task PurgeOldRecordsAsync(int months, CancellationToken cancellationToken)
    {
        var purgeDate = DateTime.UtcNow.AddMonths(-months);
        var tables = _config.GetSection("DataPurgeJob:Tables").Get<List<TableInfo>>();

        foreach (var table in tables)
        {
            await ProcessTableAsync(table, purgeDate, cancellationToken);
        }
    }

    private async Task ProcessTableAsync(TableInfo table, DateTime purgeDate, CancellationToken cancellationToken)
    {
        using var scope = _scopeFactory.CreateScope();
        var sourceDb = scope.ServiceProvider.GetRequiredService<SourceDbContext>();
        var archiveDb = scope.ServiceProvider.GetRequiredService<ArchiveDbContext>();

        var query = $"SELECT * FROM {table.Name} WHERE {table.KeyColumn} < @date";
        var parameters = new[] { new SqlParameter("@date", purgeDate) };

        var oldData = await sourceDb.Set<dynamic>().FromSqlRaw(query, parameters).ToListAsync(cancellationToken);

        foreach (var item in oldData)
        {
            await archiveDb.AddAsync(item, cancellationToken);
            sourceDb.Remove(item);
        }

        await archiveDb.SaveChangesAsync(cancellationToken);
        await sourceDb.SaveChangesAsync(cancellationToken);
    }
}
```

---

## ‚è±Ô∏è Quartz Job: `DataPurgeJob.cs`
```csharp
public class DataPurgeJob : IJob
{
    private readonly IDataPurger _purger;
    private readonly IConfiguration _config;

    public DataPurgeJob(IDataPurger purger, IConfiguration config)
    {
        _purger = purger;
        _config = config;
    }

    public async Task Execute(IJobExecutionContext context)
    {
        var months = _config.GetValue<int>("DataPurgeJob:PurgeThresholdInMonths");
        await _purger.PurgeOldRecordsAsync(months, context.CancellationToken);
    }
}
```

---

## üèóÔ∏è `Program.cs` (registro de Quartz y servicios)
```csharp
builder.Services.AddDbContext<SourceDbContext>(options =>
    options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection")));

builder.Services.AddDbContext<ArchiveDbContext>(options =>
    options.UseSqlServer(builder.Configuration.GetConnectionString("HistoricalDb")));

builder.Services.AddScoped<IDataPurger, DataPurger>();

builder.Services.AddQuartz(q =>
{
    q.UseMicrosoftDependencyInjectionJobFactory();
    var jobKey = new JobKey("DataPurgeJob");

    q.AddJob<DataPurgeJob>(opts => opts.WithIdentity(jobKey));
    q.AddTrigger(opts => opts
        .ForJob(jobKey)
        .WithIdentity("DataPurgeTrigger")
        .WithCronSchedule("0 0 3 * * ?")); // Todos los d√≠as a las 03:00
});

builder.Services.AddQuartzHostedService(opt => opt.WaitForJobsToComplete = true);
```

---

### üß† Extras √∫tiles

- Si las estructuras de tablas difieren demasiado, puedes usar `ExpandoObject` o Dapper para mayor flexibilidad.
- Aseg√∫rate de tener las migraciones listas para ambas DBs o manejar los esquemas manualmente si son independientes.
- Puedes registrar logs de las purgas con un middleware de auditor√≠a si necesitas trazabilidad.

---

¬øTe gustar√≠a que agregue manejo de errores con logs tipo `ILogger`, o incluso una opci√≥n para simular la purga (modo dry-run)?
