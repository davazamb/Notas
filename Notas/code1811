Entendido, David üë®‚Äçüíª. Si no puedes crear un √≠ndice √∫nico en la tabla B, entonces toda la l√≥gica de validaci√≥n de duplicados debe quedar en tu microservicio, dentro de la transacci√≥n, y con reintentos ante deadlocks.  

Aqu√≠ te muestro c√≥mo quedar√≠a un m√©todo √∫nico que hace todo el proceso para la tabla B sin depender de constraints en la base:

---

üõ† M√©todo √∫nico con validaci√≥n (Fecha, Factura) y MAX+1

`csharp
using System.Data;
using Microsoft.Data.SqlClient;

public class TransferService
{
    private readonly string _connB;

    public TransferService(string connB)
    {
        _connB = connB;
    }

    public async Task InsertarEnBAsync(DateTime fecha, string factura, string campo1, string campo2)
    {
        int maxIntentos = 3;
        int intento = 0;

        while (true)
        {
            try
            {
                using var conn = new SqlConnection(_connB);
                await conn.OpenAsync();

                // Transacci√≥n SERIALIZABLE para evitar condiciones de carrera
                using var tx = conn.BeginTransaction(IsolationLevel.Serializable);

                // 1. Validar existencia por Fecha+Factura
                var checkSql = "SELECT COUNT(1) FROM B WHERE Fecha = @Fecha AND Factura = @Factura";
                using var checkCmd = new SqlCommand(checkSql, conn, tx);
                checkCmd.Parameters.AddWithValue("@Fecha", fecha);
                checkCmd.Parameters.AddWithValue("@Factura", factura);

                var existe = (int)await checkCmd.ExecuteScalarAsync() > 0;
                if (existe)
                {
                    tx.Commit();
                    return; // Ya existe, no insertamos
                }

                // 2. Calcular MAX+1 del c√≥digo
                var maxSql = @"
                    SELECT ISNULL(MAX(CAST(SUBSTRING(Codigo, 2, LEN(Codigo)) AS INT)), 0) + 1
                    FROM B WITH (UPDLOCK, HOLDLOCK)";
                using var maxCmd = new SqlCommand(maxSql, conn, tx);
                var nuevoCodigoInt = (int)await maxCmd.ExecuteScalarAsync();
                var nuevoCodigo = $"B{nuevoCodigoInt}";

                // 3. Insertar
                var insertSql = @"
                    INSERT INTO B (Codigo, Fecha, Factura, Campo1, Campo2)
                    VALUES (@Codigo, @Fecha, @Factura, @Campo1, @Campo2)";
                using var insertCmd = new SqlCommand(insertSql, conn, tx);
                insertCmd.Parameters.AddWithValue("@Codigo", nuevoCodigo);
                insertCmd.Parameters.AddWithValue("@Fecha", fecha);
                insertCmd.Parameters.AddWithValue("@Factura", factura);
                insertCmd.Parameters.AddWithValue("@Campo1", campo1);
                insertCmd.Parameters.AddWithValue("@Campo2", campo2);

                await insertCmd.ExecuteNonQueryAsync();

                tx.Commit();
                break; // √âxito
            }
            catch (SqlException ex) when (ex.Number == 1205) // Deadlock
            {
                intento++;
                if (intento >= maxIntentos)
                    throw;

                // Backoff exponencial antes de reintentar
                await Task.Delay(TimeSpan.FromSeconds(Math.Pow(2, intento)));
            }
        }
    }
}
`

---

üîë Puntos clave
- Validaci√≥n sin NOLOCK: se asegura que si otro proceso est√° insertando (Fecha, Factura), tu consulta lo ver√° correctamente.  
- Transacci√≥n SERIALIZABLE + UPDLOCK/HOLDLOCK: evita que dos procesos calculen el mismo MAX+1.  
- Reintento autom√°tico: si ocurre un deadlock (SqlException 1205), el m√©todo reintenta hasta 3 veces con backoff exponencial.  
- Sin √≠ndice √∫nico: toda la l√≥gica de unicidad se controla en el c√≥digo.  

---

üëâ Con este patr√≥n, aunque no tengas √≠ndice √∫nico en la base, tu microservicio garantiza que no se inserten duplicados y que el MAX+1 sea consistente.  

¬øQuieres que te muestre c√≥mo extender este m√©todo para procesar todos los registros del d√≠a desde la tabla A en un solo flujo?